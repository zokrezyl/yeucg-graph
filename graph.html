
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Clang JSON Graph Viewer</title>
  <script src="https://cdn.jsdelivr.net/npm/vis-network@9.1.2/dist/vis-network.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/vis-network@9.1.2/styles/vis-network.min.css" rel="stylesheet">
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; font-family: sans-serif; }
    #network { width: 100%; height: 100%; border: 1px solid lightgray; }
  </style>
</head>
<body>
  <div id="network"></div>

  <script>
    const dataUrl = './clang.json';
    let fullData = {};
    let reverseRefs = {};
    let forwardRefs = {};
    let nodes = new vis.DataSet();
    let edges = new vis.DataSet();

    const container = document.getElementById('network');
    const network = new vis.Network(container, { nodes, edges }, {
      layout: { improvedLayout: true },
      interaction: { hover: true },
      physics: { stabilization: true },
    });

    fetch(dataUrl)
      .then(res => res.json())
      .then(json => {
        fullData = json;
        buildReferenceMaps(json);
        if (Object.keys(json).length > 0) {
          const rootId = Object.keys(json)[0];
          showSubgraph(rootId);
        }
      });

    function buildReferenceMaps(data) {
      reverseRefs = {};
      forwardRefs = {};
      for (const [id, obj] of Object.entries(data)) {
        forwardRefs[id] = new Set();
        walkObject(id, obj, (refId) => {
          forwardRefs[id].add(refId);
          if (!(refId in reverseRefs)) reverseRefs[refId] = new Set();
          reverseRefs[refId].add(id);
        });
      }
    }

    function makeLabel(id, obj) {
      const type = obj.__meta?.type || '?';
      return `${id}\n(${type})`;
    }

    function getTypeColor(type) {
      const palette = {
        'TranslationUnit': '#FFD966',
        'Cursor': '#A4C2F4',
        'Type': '#D9EAD3',
        'File': '#F4CCCC',
        'SourceLocation': '#D5A6BD',
        'SourceRange': '#B6D7A8',
        '?': '#CCCCCC'
      };
      return palette[type] || '#E0E0E0';
    }

    function showSubgraph(centerId) {
      nodes.clear();
      edges.clear();
      if (!(centerId in fullData)) return;

      const center = fullData[centerId];
      const centerType = center.__meta?.type || '?';
      nodes.add({ id: centerId, label: makeLabel(centerId, center), color: getTypeColor(centerType) });

      // Outgoing references
      if (forwardRefs[centerId]) {
        forwardRefs[centerId].forEach(refId => {
          if (refId in fullData) {
            const ref = fullData[refId];
            const refType = ref.__meta?.type || '?';
            nodes.add({ id: refId, label: makeLabel(refId, ref), color: getTypeColor(refType) });
            edges.add({ from: centerId, to: refId, label: 'refers', arrows: 'to' });
          }
        });
      }

      // Incoming references
      if (reverseRefs[centerId]) {
        reverseRefs[centerId].forEach(fromId => {
          if (fromId in fullData) {
            const from = fullData[fromId];
            const fromType = from.__meta?.type || '?';
            nodes.add({ id: fromId, label: makeLabel(fromId, from), color: getTypeColor(fromType) });
            edges.add({ from: fromId, to: centerId, label: 'refers', arrows: 'to' });
          }
        });
      }

      network.fit({ nodes: [centerId], animation: true });
    }

    function walkObject(parentId, obj, onRef) {
      if (!obj || typeof obj !== 'object') return;
      for (const [key, val] of Object.entries(obj)) {
        if (val && typeof val === 'object') {
          if ('__ref' in val) {
            onRef(val.__ref, key);
          } else {
            walkObject(parentId, val, onRef);
          }
        } else if (Array.isArray(val)) {
          val.forEach(entry => {
            if (entry && typeof entry === 'object') {
              if ('__ref' in entry) {
                onRef(entry.__ref, key);
              } else {
                walkObject(parentId, entry, onRef);
              }
            }
          });
        }
      }
    }

    network.on('doubleClick', function (params) {
      if (params.nodes.length > 0) {
        const clickedId = params.nodes[0];
        showSubgraph(clickedId);
      }
    });
  </script>
</body>
</html>
